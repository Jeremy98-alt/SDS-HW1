G <- graph( edges=c(6,9, 9,5, 9,2, 9,10, 10,2, 10,5, 10,7, 10,4, 5,7, 5,8, 2,7, 2,4, 4,1, 4,8, 8,3, 8,1, 7,8),  n=10, directed=F)
plot(G)
#run the library and search our max-cut(G)
library(sdpt3r)
#firstly search to create our adjacency_matrix from G
adj <- as_adjacency_matrix(G, type = "both",
attr = NULL, edges = FALSE)
#convert S4 object to matrix
adj <- matrix(adj, ncol = gsize(G), nrow = gsize(G))
#maximum cut
result <- maxcut(adj)
#return the maximum cut, use the value returned
maxcut <- abs(result$pobj)
maxcut
#matrix correlation or... X
result$Z
#should be a RANDOM GRAPH
G <- graph( edges=c(1,2, 2,3, 1,4, 4,3, 3,5, 5,6, 5,7)),  n=7, directed=F)
plot(G)
#run the library and search our max-cut(G)
library(sdpt3r)
#firstly search to create our adjacency_matrix from G
adj <- as_adjacency_matrix(G, type = "both",
attr = NULL, edges = FALSE)
#convert S4 object to matrix
adj <- matrix(adj, ncol = gsize(G), nrow = gsize(G))
#maximum cut
result <- maxcut(adj)
#return the maximum cut, use the value returned
maxcut <- abs(result$pobj)
maxcut
#matrix correlation or... X
result$Z
plot(G)
plot(G)
g <- erdos.renyi.game(1000, 1/1000)
degree_distribution(g)g <- erdos.renyi.game(1000, 1/1000)
degree_distribution(g)
g <- erdos.renyi.game(1000, 1/1000)
plot(g)
g <- erdos.renyi.game(10, 1/10)
plot(g)
g <- erdos.renyi.game(10, 1)
degree_distribution(g)
plot(g)
g <- erdos.renyi.game(10, 1/2)
degree_distribution(g)
plot(g)
G <- graph( edges=c(1,2, 2,3, 1,4, 4,3, 3,5, 5,6, 5,7)),  n=7, directed=F)
plot(G)
G <- graph( edges=c(1,2, 2,3, 1,4, 4,3, 3,5, 5,6, 5,7)),  n=7, directed=F)
plot(G)
G <- graph( edges=c(1,2, 2,3, 1,4, 4,3, 3,5, 5,6, 5,7)),  n=7, directed=F)
plot(G)
G <- graph( edges=c(1,2, 2,3, 1,4, 4,3, 3,5, 5,6, 5,7)),  n=7, directed=F)
plot(G)
Vertex.name <- V(G)$name
Vertex <- V(G)$name
rm(Vertex, Vertex.name)
#should be a RANDOM GRAPH
#g <- erdos.renyi.game(10, 1/2)
#plot(g)
G <- graph( edges=c(1,2, 2,3, 1,4, 4,3, 3,5, 5,6, 5,7),  n=7, directed=F)
plot(G)
Vertex <- V(G)$name
G
Vertex <- vertex_attr(G)
Vertex
Vertex <- V(G)
Vertex
#get the vertex's names
vertex.names <- V(G)
rm(Vertex)
#firstly search to create our adjacency_matrix from G
adj <- as_adjacency_matrix(G, type = "both",
attr = NULL, edges = FALSE)
#convert S4 object to matrix
adj <- matrix(adj, ncol = gsize(G), nrow = gsize(G))
#maximum cut
result <- maxcut(adj)
#return the maximum cut, use the value returned
maxcut <- abs(result$pobj)
maxcut
#matrix correlation or... X
result$Z
typeof(vertex.names)
U <- c()
U <- c()
?binom
?rbinom
?dbern
?rbern
bern
?bern
?dbern
install.packages('Rlab')
library(Rlab)
dbern(10, 0.5)
dbern(1, 0.5)
dbern(2, 0.5)
dbern(3, 0.5)
dbern(3, 1/2)
dbern(3, 1/2)
dbern(3, 1/2)
dbern(3, 1/2)
dbern(3, 1/2)
dbern(3, 1/2)
dbern(3, 1/2)
dbern(3, 1/2)
dbern(3, 1/2)
dbern(3, 1/2)
dbern(3, 1/2)
dbern(3, 1/2)
dbern(3, 1/2)
dbern(3, 1/2)
dbern(3, 1/2)
dbern(4, 1/2)
dbern(5, 1/2)
dbern(6, 1/2)
dbern(7, 1/2)
dbinom(10, 1, 0.5)
rbinom(10, 1, 0.5)
rbinom(1000, 1, 0.5)
rbinom(1, 1, 0.5)
rbinom(1, 1, 0.5)
rbinom(1, 1, 0.5)
rbinom(1, 1, 0.5)
rbinom(1, 1, 0.5)
rbinom(1, 1, 0.5)
rbinom(1, 1, 0.5)
rbinom(1, 1, 0.5)
rbinom(1, 1, 0.5)
rbinom(1, 1, 0.5)
rbinom(1, 1, 0.5)
rbinom(1, 1, 0.5)
rbinom(1, 1, 0.5)
rbinom(1, 1, 0.5)
rbern(1, 0.5)
rbern(1, 0.5)
rbern(1, 0.5)
rbern(1, 0.5)
rbern(1, 0.5)
rbern(1, 0.5)
rbern(1, 0.5)
randomizedMaxCut <- function(vertex.names, M){
U <- c()
for(i in 1:M){
randBern <- rbern(1, 0.5)
if(randBern == 1)
U <- append(U, vertex.names)
}
return(U)
}
#try M times to generate the subset of V
U <- randomizedMaxCut(vertex.names, 7)
#create the function for our goal
randomizedMaxCut = function(vertex.names, M){
U <- c()
for(i in 1:M){
randBern <- rbern(1, 0.5)
if(randBern == 1)
U <- append(U, vertex.names)
}
return(U)
}
#get the vertex's names
vertex.names <- V(G)
#try M times to generate the subset of V
U <- randomizedMaxCut(vertex.names, 7)
#get the vertex's names
vertex.names <- V(G)$name
#get the vertex's names
vertex.names <- V(G)
vertex.names[1]
string(V(G))
as.character(V(G))
#get the vertex's names
vertex.names <- as.character(V(G))
vertex.names[i]
vertex.names[2]
vertex.names[4]
#create the function for our goal
randomizedMaxCut = function(vertex.names, M){
U <- c()
for(i in 1:M){
randBern <- rbern(1, 0.5)
if(randBern == 1)
U <- append(U, vertex.names[i])
}
return(U)
}
randomizedMaxCut()
randomizedMaxCut
#get the vertex's names
vertex.names <- as.character(V(G))
#try M times to generate the subset of V
U <- randomizedMaxCut(vertex.names, 7)
U
#try M times to generate the subset of V
U <- randomizedMaxCut(vertex.names, 7)
U
#try M times to generate the subset of V
U <- randomizedMaxCut(vertex.names, 7)
U
#create the function for our goal to obtain our subset of V
randomizedMaxCut <- function(vertex.names, M){
U <- c()
for(i in 1:M){
randBern <- rbern(1, 0.5)
if(randBern == 1)
U <- append(U, vertex.names[i])
}
return(U)
}
#try M times to generate the subset of V
U <- randomizedMaxCut(vertex.names, 7)
U
theoretical.bound <- maxcut/2
theoretical.bound
E(G)
as.character(E(G))
typeof(E(G))
as_ids(G)
as_ids(E(G))
U
#get the vertex's names, convert into vector string
vertex.names <- as_ids(V(G))
vertex.names
#try M times to generate the subset of V
U <- randomizedMaxCut(vertex.names, 7)
U
averageCutSize <- function(vertex.names, M){
}
#try M times to generate the subset of V
U <- randomizedMaxCut(vertex.names, 7)
U
#should be a RANDOM GRAPH
#g <- erdos.renyi.game(10, 1/2)
#plot(g)
G <- graph( edges=c(1,2, 2,3, 1,4, 4,3, 3,5, 5,6, 5,7),  n=7, directed=F)
plot(G)
#firstly search to create our adjacency_matrix from G
adj <- as_adjacency_matrix(G, type = "both",
attr = NULL, edges = FALSE)
#convert S4 object to matrix
adj <- matrix(adj, ncol = gsize(G), nrow = gsize(G))
#maximum cut
result <- maxcut(adj)
#return the maximum cut, use the value returned
maxcut <- abs(result$pobj)
maxcut
#matrix correlation or... X
result$Z
#create the function for our goal to obtain our subset of V
subset.V <- function(vertex.names, M){
U <- c()
for(i in 1:M){
randBern <- rbern(1, 0.5)
if(randBern == 1)
U <- append(U, vertex.names[i])
}
return(U)
}
vertex.names <- as_ids(V(G))
#try M times to generate the subset of V
U <- subset.V(vertex.names, 7)
U
theoretical.bound <- maxcut/2
as_ids(E(G))
E(G)
c((2,3))
c(2,3)
do.call(rbind, get.adjlist(G))
E(g)[V(g) %--% V(g)]
E(G)[V(G) %--% V(G)]
as.character(E(G)[V(G) %--% V(G)])
adj
which(adj==1, arr.ind = TRUE)
#create the list of edges from our G graph
list.edges <- which(adj==1, arr.ind = TRUE)
list.edges
#create the list of edges from our G graph
list.edges <- which((upper.tri(adj, diag=FALSE))==1, arr.ind = TRUE)
list.edges
upper.tri(adj, diag=FALSE)
#create the list of edges from our G graph
upper.adj <- upper.tri(adj, diag=FALSE)
#create the list of edges from our G graph
upper.adj <- adj[upper.tri(adj, diag=FALSE)]
upper.adj
#create the list of edges from our G graph
upper.adj <- matrix(adj[upper.tri(adj, diag=FALSE)])
upper.adj
#create the list of edges from our G graph
adj[upper.tri(adj, diag=FALSE)] <- 0
adj
#firstly search to create our adjacency_matrix from G
adj <- as_adjacency_matrix(G, type = "both",
attr = NULL, edges = FALSE)
#convert S4 object to matrix
adj <- matrix(adj, ncol = gsize(G), nrow = gsize(G))
#create the list of edges from our G graph
adj[lower.tri(adj, diag=FALSE)] <- 0
adj
list.edges <- which(upper.adj==1, arr.ind = TRUE)
list.edges
list.edges <- which(adj==1, arr.ind = TRUE)
list.edges
typeof(list.edges)
list.edges["row"]
list.edges[row]
list.edges[1]
list.edges[2]
list.edges[,row]
list.edges[, "row"]
list.edges[1, 1]
list.edges[1, 2]
#create subset U edges for the maxcut..
edges.U <- function(U, list.edges){
edges <- c()
for(row in 1:nrow(list.edges)){
if( (list.edges[row, 1] %in% U) && (list.edges[row, 2] %notin% U) ){
edges.append(edges, c(list.edges[row, 1], list.edges[row, 2]) )
}
}
return(edges)
}
make.U.graph <- edges.U(U, list.edges)
#create subset U edges for the maxcut..
edges.U <- function(U, list.edges){
edges <- c()
`%notin%` <- Negate(`%in%`)
for(row in 1:nrow(list.edges)){
if( (list.edges[row, 1] %in% U) && (list.edges[row, 2] %notin% U) ){
edges.append(edges, c(list.edges[row, 1], list.edges[row, 2]) )
}
}
return(edges)
}
make.U.graph <- edges.U(U, list.edges)
#create subset U edges for the maxcut..
edges.U <- function(U, list.edges){
edges <- c()
`%notin%` <- Negate(`%in%`) #define new operator
for(row in 1:nrow(list.edges)){
if( (list.edges[row, 1] %in% U) && (list.edges[row, 2] %notin% U) ){
edges <- append(edges, c(list.edges[row, 1], list.edges[row, 2]) )
}
}
return(edges)
}
make.U.graph <- edges.U(U, list.edges)
make.U.graph
typeof(make.U.graph)
int(make.U.graph)
colnames(list.edges) <- c("V1", "V2") #change columns name..
list.edges
make.U.graph <- edges.U(U, list.edges)
make.U.graph
len(U)
size(U)
lenght(U)
length(U)
#create subset U edges for the maxcut..
edges.U <- function(U, list.edges){
edges <- c()
`%notin%` <- Negate(`%in%`) #define new operator
for(row in 1:nrow(list.edges)){
if( (list.edges[row, 1] %in% U) && (list.edges[row, 2] %notin% U) ){
edges <- append(edges, c(list.edges[row, 1], list.edges[row, 2]) )
}
}
subgraph.U <- graph(edges, n=length(U), directed=F)
}
make.U.graph <- edges.U(U, list.edges)
plot(make.U.graph)
edges.U()
U
#create subset U edges for the maxcut..
edges.U <- function(U, list.edges){
edges <- c()
`%notin%` <- Negate(`%in%`) #define new operator
for(row in 1:nrow(list.edges)){
if( (list.edges[row, 1] %in% U) && (list.edges[row, 2] %notin% U) ){
edges <- append(edges, c(list.edges[row, 1], list.edges[row, 2]) )
}
}
subgraph.U <- graph(edges, n=length(U), directed=F)
return(edges)
}
make.U.graph <- edges.U(U, list.edges)
make.U.graph
U
list.edges
#create subset U edges for the maxcut..
edges.U <- function(U, list.edges){
edges <- c()
`%notin%` <- Negate(`%in%`) #define new operator
for(row in 1:nrow(list.edges)){
if( (list.edges[row, 1] %in% U) && (list.edges[row, 2] %notin% U) ){
edges <- append(edges, c(list.edges[row, 1], list.edges[row, 2]) )
}
}
subgraph.U <- graph(edges, n=length(U), directed=F)
return(subgraph.U)
}
make.U.graph <- edges.U(U, list.edges)
plot(make.U.graph)
#calculate M times and return the average cut size
averageCutSize <- function(U, M, G, list.edges){
avg.cutsize <- c()
for(i in 1:M){
U <- subset.V(vertex.names, gsize(G))
make.U.graph <- edges.U(U, list.edges)
#make the adjacency matrix of U like in the previous example
adjU <- as_adjacency_matrix(make.U.graph, type = "both",
attr = NULL, edges = FALSE)
#convert S4 object to matrix
adjU <- matrix(adjU, ncol = gsize(make.U.graph), nrow = gsize(make.U.graph))
#append the result
avg.cutsize <- append(avg.cutsize, abs(maxcut(adjU)$pobj) )
}
#finally return the mean!
return(mean(avg.cutsize))
}
#call M times the averageCutSize
averageCutSize(U, gsize(G), G, list.edges)
#calculate M times and return the average cut size
averageCutSize <- function(M, G, list.edges){
avg.cutsize <- c()
for(i in 1:M){
U <- subset.V(vertex.names, gsize(G))
make.U.graph <- edges.U(U, list.edges)
#make the adjacency matrix of U like in the previous example
adjU <- as_adjacency_matrix(make.U.graph, type = "both",
attr = NULL, edges = FALSE)
#convert S4 object to matrix
adjU <- matrix(adjU, ncol = gsize(make.U.graph), nrow = gsize(make.U.graph))
#append the result
avg.cutsize <- append(avg.cutsize, abs(maxcut(adjU)$pobj) )
}
#finally return the mean!
return(mean(avg.cutsize))
}
#calculate M times and return the average cut size
averageCutSize <- function(vertex.names, M, list.edges){
avg.cutsize <- c()
for(i in 1:M){
U <- subset.V(vertex.names, M)
make.U.graph <- edges.U(U, list.edges)
#make the adjacency matrix of U like in the previous example
adjU <- as_adjacency_matrix(make.U.graph, type = "both",
attr = NULL, edges = FALSE)
#convert S4 object to matrix
adjU <- matrix(adjU, ncol = gsize(make.U.graph), nrow = gsize(make.U.graph))
#append the result
avg.cutsize <- append(avg.cutsize, abs(maxcut(adjU)$pobj) )
}
#finally return the mean!
return(mean(avg.cutsize))
}
#call M times the averageCutSize
averageCutSize(vertex.names, gsize(G), list.edges)
#call M times the averageCutSize
averageCutSize(vertex.names, gsize(G), list.edges)
#calculate M times and return the average cut size
averageCutSize <- function(vertex.names, M, list.edges){
avg.cutsize <- c()
for(i in 1:M){
U <- subset.V(vertex.names, M)
make.U.graph <- edges.U(U, list.edges)
#make the adjacency matrix of U like in the previous example
adjU <- as_adjacency_matrix(make.U.graph, type = "both",
attr = NULL, edges = FALSE)
#convert S4 object to matrix
adjU <- matrix(adjU, ncol = gsize(make.U.graph), nrow = gsize(make.U.graph))
#append the result
avg.cutsize <- append(avg.cutsize, abs(maxcut(adjU)$pobj) )
}
#finally return the mean!
return(mean(avg.cutsize))
}
debugSource('D:/UNIVERSITA\'/MASTER DEGREE - La Sapienza/SDS - Statistical Methods in Data Science/Lectures/HOMEWORK/HW1/HW1/PartA.R')
#calculate M times and return the average cut size
averageCutSize <- function(vertex.names, M, list.edges){
avg.cutsize <- c()
for(i in 1:M){
U <- subset.V(vertex.names, M)
make.U.graph <- edges.U(U, list.edges)
V(make.U.graph)
E(make.U.graph)
plot(make.U.graph)
#make the adjacency matrix of U like in the previous example
adjU <- as_adjacency_matrix(make.U.graph, type = "both",
attr = NULL, edges = FALSE)
adjU
#convert S4 object to matrix
adjU <- matrix(adjU, ncol = gsize(make.U.graph), nrow = gsize(make.U.graph))
#append the result
avg.cutsize <- append(avg.cutsize, abs(maxcut(adjU)$pobj) )
}
#finally return the mean!
return(mean(avg.cutsize))
}
debugSource('D:/UNIVERSITA\'/MASTER DEGREE - La Sapienza/SDS - Statistical Methods in Data Science/Lectures/HOMEWORK/HW1/HW1/PartA.R')
#call M times the averageCutSize
averageCutSize(vertex.names, gsize(G), list.edges)
debugSource('D:/UNIVERSITA\'/MASTER DEGREE - La Sapienza/SDS - Statistical Methods in Data Science/Lectures/HOMEWORK/HW1/HW1/PartA.R')
debugSource('D:/UNIVERSITA\'/MASTER DEGREE - La Sapienza/SDS - Statistical Methods in Data Science/Lectures/HOMEWORK/HW1/HW1/PartA.R')
debugSource('D:/UNIVERSITA\'/MASTER DEGREE - La Sapienza/SDS - Statistical Methods in Data Science/Lectures/HOMEWORK/HW1/HW1/PartA.R')
debugSource('D:/UNIVERSITA\'/MASTER DEGREE - La Sapienza/SDS - Statistical Methods in Data Science/Lectures/HOMEWORK/HW1/HW1/PartA.R')
gsize(make.U.graph)
